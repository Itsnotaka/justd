"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
var fs = require("fs");
var path = require("path");
var baseDir = path.resolve(__dirname, '../../components');
var docsDir = path.join(baseDir, 'docs');
var uiDir = path.join(baseDir, 'ui');
var outputMapFilePath = path.resolve(docsDir, 'generated/previews.ts');
var jsonOutputFilePath = path.resolve(docsDir, 'generated/previews.json');
function getAllFiles(dirPath, arrayOfFiles) {
    if (arrayOfFiles === void 0) { arrayOfFiles = []; }
    // Exclude directories: 'rehype' in 'docs' and 'outside' in base directory
    if (dirPath.endsWith(path.join('docs', 'rehype')) || dirPath.endsWith('outside')) {
        return arrayOfFiles; // Skip these directories and their contents
    }
    var files = fs.readdirSync(dirPath);
    files.forEach(function (file) {
        var filePath = path.join(dirPath, file);
        if (fs.statSync(filePath).isDirectory()) {
            arrayOfFiles = getAllFiles(filePath, arrayOfFiles);
        }
        else if (file.endsWith('.tsx')) {
            arrayOfFiles.push(filePath);
        }
    });
    return arrayOfFiles;
}
var components = __spreadArray(__spreadArray([], getAllFiles(docsDir), true), getAllFiles(uiDir), true).filter(function (filePath) { return !filePath.includes('/how') && !filePath.includes('/props'); }) // Exclude specific components
    .reduce(function (acc, filePath) {
    var content = fs.readFileSync(filePath, 'utf8'); // Read the file content
    var relativePath = path.relative(baseDir, filePath).replace(/\\/g, '/').replace('.tsx', '');
    var importPath = "@/components/".concat(relativePath);
    var key = relativePath.split('/').slice(1).join('/');
    var type = filePath.startsWith(docsDir) ? 'docs' : 'ui'; // Determine type based on folder path
    if (type === 'docs') {
        acc.tsComponents[key] = {
            component: importPath
        };
    }
    acc.jsonComponents[key] = {
        component: importPath,
        raw: content,
        type: type // Include type for JSON only
    };
    return acc;
}, { tsComponents: {}, jsonComponents: {} });
var previewsContent = '// @ts-nocheck\n';
previewsContent += '// This file is autogenerated by scripts/create-pr-content.ts.\n';
previewsContent += '// Do not edit this file directly.\n\n';
previewsContent += "import React from 'react';\n\n";
previewsContent += 'export const previews: Record<string, any> = {\n';
Object.entries(components.tsComponents).forEach(function (_a) {
    var key = _a[0], component = _a[1].component;
    previewsContent += "  \"".concat(key, "\": {\n");
    previewsContent += "    component: React.lazy(() => import(\"".concat(component, "\")),\n");
    previewsContent += "  },\n";
});
previewsContent += '};\n';
fs.writeFileSync(outputMapFilePath, previewsContent);
console.log("Component map generated into ".concat(outputMapFilePath));
fs.writeFileSync(jsonOutputFilePath, JSON.stringify(components.jsonComponents, null, 2));
console.log("Component JSON generated into ".concat(jsonOutputFilePath));
